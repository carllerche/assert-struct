//! Error types and formatting for assert_struct macro failures.

use std::fmt;

/// Comparison operators used in patterns.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ComparisonOp {
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Equal,
    NotEqual,
}

impl ComparisonOp {
    /// Get the string representation of this operator
    pub fn as_str(&self) -> &'static str {
        match self {
            ComparisonOp::Less => "<",
            ComparisonOp::LessEqual => "<=",
            ComparisonOp::Greater => ">",
            ComparisonOp::GreaterEqual => ">=",
            ComparisonOp::Equal => "==",
            ComparisonOp::NotEqual => "!=",
        }
    }
}

/// Context information for a failed assertion.
#[derive(Debug, Clone)]
pub struct ErrorContext {
    pub actual_value: String,
    pub line_number: u32,
    /// For equality patterns where we need to show the expected value
    pub expected_value: Option<String>,
    /// The specific pattern node that failed
    pub error_node: &'static PatternNode,
}

impl ErrorContext {
    fn error_type(&self) -> ErrorType {
        match &self.error_node.kind {
            NodeKind::Comparison { op, .. } => {
                if matches!(op, ComparisonOp::Equal) {
                    ErrorType::Equality
                } else {
                    ErrorType::Comparison
                }
            }
            NodeKind::Range { .. } => ErrorType::Range,
            NodeKind::Regex { .. } => ErrorType::Regex,
            NodeKind::Like { .. } => ErrorType::Regex,
            NodeKind::Simple { .. } => ErrorType::Value,
            NodeKind::EnumVariant { .. } => ErrorType::EnumVariant,
            NodeKind::Slice { .. } => ErrorType::Slice,
            NodeKind::Closure { .. } => ErrorType::Closure,
            _ => ErrorType::Value,
        }
    }
}

/// The type of error that occurred, inferred from the pattern node.
enum ErrorType {
    Comparison,
    Range,
    Regex,
    Value,
    EnumVariant,
    Slice,
    Equality,
    Closure,
}

/// Tree-based pattern representation, generated by the macro at compile time.
pub struct PatternNode {
    pub kind: NodeKind,
    pub parent: Option<&'static PatternNode>,
    pub line: u32,
    pub column: u32,
}

/// The kind of pattern node.
#[derive(Debug)]
pub enum NodeKind {
    // Structural patterns
    Struct {
        name: &'static str,
        fields: &'static [(&'static str, &'static PatternNode)],
    },

    // Collection patterns
    Slice {
        items: &'static [&'static PatternNode],
    },
    Tuple {
        items: &'static [&'static PatternNode],
    },
    Map {
        entries: &'static [(&'static str, &'static PatternNode)],
    },

    // Enum patterns
    EnumVariant {
        path: &'static str,
        args: Option<&'static [&'static PatternNode]>,
    },

    // Leaf patterns
    Simple {
        value: &'static str,
    },
    Comparison {
        op: ComparisonOp,
        value: &'static str,
    },
    Range {
        pattern: &'static str,
    },
    Regex {
        pattern: &'static str,
    },
    Like {
        expr: &'static str,
    },

    // Special
    Rest,
    Wildcard,
    Closure {
        closure: &'static str,
    },
}

impl fmt::Debug for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PatternNode")
            .field("kind", &self.kind)
            .field("parent", &self.parent.map(|_| "<parent>"))
            .field("line", &self.line)
            .field("column", &self.column)
            .finish()
    }
}

impl fmt::Display for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.kind {
            NodeKind::Struct { name, .. } => write!(f, "{} {{ ... }}", name),
            NodeKind::Slice { .. } => write!(f, "[...]"),
            NodeKind::Tuple { items } => write!(f, "({})", ".., ".repeat(items.len())),
            NodeKind::Map { entries } => write!(f, "#{{ {} entries }}", entries.len()),
            NodeKind::EnumVariant { path, args } => {
                if args.is_some() {
                    write!(f, "{}(...)", path)
                } else {
                    write!(f, "{}", path)
                }
            }
            NodeKind::Simple { value } => write!(f, "{}", value),
            NodeKind::Comparison { op, value } => write!(f, "{} {}", op.as_str(), value),
            NodeKind::Range { pattern } => write!(f, "{}", pattern),
            NodeKind::Regex { pattern } => write!(f, "=~ {}", pattern),
            NodeKind::Like { expr } => write!(f, "=~ {}", expr),
            NodeKind::Rest => write!(f, ".."),
            NodeKind::Wildcard => write!(f, "_"),
            NodeKind::Closure { closure } => write!(f, "{}", closure),
        }
    }
}

/// Format assertion errors into a human-readable message.
pub fn format_errors_with_root(
    _root: &'static PatternNode,
    errors: Vec<ErrorContext>,
    _root_name: &str,
) -> String {
    let mut lines = vec!["assert_struct! failed:".to_string()];

    for error in &errors {
        let msg = match error.error_type() {
            ErrorType::Equality => format!(
                "expected {}, got {}",
                error.expected_value.as_deref().unwrap_or("?"),
                error.actual_value,
            ),
            ErrorType::EnumVariant => format!(
                "expected variant {}, got {}",
                error.error_node,
                error.actual_value,
            ),
            ErrorType::Slice => format!(
                "slice length or structure mismatch, got {}",
                error.actual_value,
            ),
            ErrorType::Closure => format!(
                "closure condition not satisfied, got {}",
                error.actual_value,
            ),
            _ => format!(
                "expected {} to match {}",
                error.actual_value,
                error.error_node,
            ),
        };

        lines.push(msg);
    }

    lines.join("\n")
}
