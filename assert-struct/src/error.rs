//! Error types and formatting for assert_struct macro failures.

use std::fmt;

/// Context information for a failed assertion.
#[derive(Debug, Clone)]
#[allow(dead_code)]
struct ErrorContext {
    actual_value: String,
    line_number: u32,
    /// For equality patterns where we need to show the expected value
    expected_value: Option<String>,
    /// The specific pattern node that failed
    error_node: &'static PatternNode,
}

/// Collected assertion errors for reporting.
#[derive(Debug)]
pub struct ErrorReport {
    errors: Vec<ErrorContext>,
    file_path: String,
}

impl ErrorReport {
    pub fn new(file_path: &str) -> Self {
        ErrorReport {
            errors: Vec::new(),
            file_path: file_path.to_string(),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.errors.is_empty()
    }

    pub fn push(
        &mut self,
        error_node: &'static PatternNode,
        line_number: u32,
        actual: String,
        expected: Option<String>,
    ) {
        self.errors.push(ErrorContext {
            actual_value: actual,
            line_number,
            expected_value: expected,
            error_node,
        });
    }
}

impl fmt::Display for ErrorReport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.errors.is_empty() {
            return Ok(());
        }

        write!(f, "assert_struct! failed:")?;

        for error in &self.errors {
            let msg = match &error.error_node.kind {
                NodeKind::Comparison {
                    op: ComparisonOp::Equal,
                    ..
                } => format!(
                    "\nexpected {}, got {}",
                    error.expected_value.as_deref().unwrap_or("?"),
                    error.actual_value,
                ),
                NodeKind::EnumVariant { .. } => format!(
                    "\nexpected variant {}, got {}",
                    error.error_node, error.actual_value,
                ),
                NodeKind::Slice { .. } => format!(
                    "\nslice length or structure mismatch, got {}",
                    error.actual_value,
                ),
                NodeKind::Closure { .. } => format!(
                    "\nclosure condition not satisfied, got {}",
                    error.actual_value,
                ),
                _ => format!(
                    "\nexpected {} to match {}",
                    error.actual_value, error.error_node,
                ),
            };

            write!(f, "{}", msg)?;
        }

        Ok(())
    }
}

/// Tree-based pattern representation, generated by the macro at compile time.
pub struct PatternNode {
    pub kind: NodeKind,
    pub parent: Option<&'static PatternNode>,
    pub line: u32,
    pub column: u32,
}

/// The kind of pattern node.
#[derive(Debug)]
pub enum NodeKind {
    // Structural patterns
    Struct {
        name: &'static str,
        fields: &'static [(&'static str, &'static PatternNode)],
    },

    // Collection patterns
    Slice {
        items: &'static [&'static PatternNode],
    },
    Tuple {
        items: &'static [&'static PatternNode],
    },
    Map {
        entries: &'static [(&'static str, &'static PatternNode)],
    },

    // Enum patterns
    EnumVariant {
        path: &'static str,
        args: Option<&'static [&'static PatternNode]>,
    },

    // Leaf patterns
    Simple {
        value: &'static str,
    },
    Comparison {
        op: ComparisonOp,
        value: &'static str,
    },
    Range {
        pattern: &'static str,
    },
    Regex {
        pattern: &'static str,
    },
    Like {
        expr: &'static str,
    },

    // Special
    Rest,
    Wildcard,
    Closure {
        closure: &'static str,
    },
}

/// Comparison operators used in patterns.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ComparisonOp {
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Equal,
    NotEqual,
}

impl ComparisonOp {
    /// Get the string representation of this operator
    pub fn as_str(&self) -> &'static str {
        match self {
            ComparisonOp::Less => "<",
            ComparisonOp::LessEqual => "<=",
            ComparisonOp::Greater => ">",
            ComparisonOp::GreaterEqual => ">=",
            ComparisonOp::Equal => "==",
            ComparisonOp::NotEqual => "!=",
        }
    }
}

impl fmt::Debug for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PatternNode")
            .field("kind", &self.kind)
            .field("parent", &self.parent.map(|_| "<parent>"))
            .field("line", &self.line)
            .field("column", &self.column)
            .finish()
    }
}

impl fmt::Display for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.kind {
            NodeKind::Struct { name, .. } => write!(f, "{} {{ ... }}", name),
            NodeKind::Slice { .. } => write!(f, "[...]"),
            NodeKind::Tuple { items } => write!(f, "({})", ".., ".repeat(items.len())),
            NodeKind::Map { entries } => write!(f, "#{{ {} entries }}", entries.len()),
            NodeKind::EnumVariant { path, args } => {
                if args.is_some() {
                    write!(f, "{}(...)", path)
                } else {
                    write!(f, "{}", path)
                }
            }
            NodeKind::Simple { value } => write!(f, "{}", value),
            NodeKind::Comparison { op, value } => write!(f, "{} {}", op.as_str(), value),
            NodeKind::Range { pattern } => write!(f, "{}", pattern),
            NodeKind::Regex { pattern } => write!(f, "=~ {}", pattern),
            NodeKind::Like { expr } => write!(f, "=~ {}", expr),
            NodeKind::Rest => write!(f, ".."),
            NodeKind::Wildcard => write!(f, "_"),
            NodeKind::Closure { closure } => write!(f, "{}", closure),
        }
    }
}
