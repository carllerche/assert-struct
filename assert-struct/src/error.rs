//! Error types and formatting for assert_struct macro failures.

use std::fmt;
use std::path::PathBuf;

use annotate_snippets::{AnnotationKind, Level, Renderer, Snippet};

/// Derive the absolute source file path from two compile-time constants:
/// - `manifest_dir`: value of `env!("CARGO_MANIFEST_DIR")` — absolute path to the package root
/// - `file_path`: value of `file!()` — path relative to the workspace root
///
/// In a Rust workspace, `file!()` is workspace-root-relative while `CARGO_MANIFEST_DIR`
/// is package-root-absolute. The package dir name(s) appear as a suffix of `manifest_dir`
/// and as a matching prefix of `file_path`. By stripping that overlap we get the workspace
/// root, then join with `file_path` for a fully absolute path.
///
/// Example (flat workspace):
///   manifest_dir = /workspace/my-crate
///   file_path    = my-crate/src/lib.rs
///   overlap      = my-crate  →  workspace root = /workspace
///   result       = /workspace/my-crate/src/lib.rs
///
/// Works for nested members too (overlap spans multiple path components).
fn absolute_source_path(manifest_dir: &str, file_path: &str) -> PathBuf {
    use std::path::Path;

    let manifest = Path::new(manifest_dir);
    let file = Path::new(file_path);

    // Collect path components for each side.
    let manifest_components: Vec<_> = manifest.components().collect();
    let file_components: Vec<_> = file.components().collect();

    // Find the longest suffix of manifest_components that matches a prefix of file_components.
    let mut overlap = 0;
    for len in 1..=manifest_components.len().min(file_components.len()) {
        let suffix = &manifest_components[manifest_components.len() - len..];
        let prefix = &file_components[..len];
        if suffix == prefix {
            overlap = len;
        }
    }

    // Workspace root = manifest_dir minus the overlapping suffix.
    let workspace_root: PathBuf = manifest_components[..manifest_components.len() - overlap]
        .iter()
        .collect();

    workspace_root.join(file)
}

/// Compute the byte offset of a (line, col) position within a source string.
/// Both `line` and `col` are 1-indexed (as returned by Rust's `line!()` / `column!()`).
fn byte_offset_of(source: &str, line: u32, col: u32) -> usize {
    let line_start: usize = source
        .split('\n')
        .take((line - 1) as usize)
        .map(|l| l.len() + 1) // +1 for the '\n'
        .sum();
    (line_start + col.saturating_sub(1) as usize).min(source.len())
}

/// Context information for a failed assertion.
#[derive(Debug, Clone)]
#[allow(dead_code)]
struct ErrorContext {
    actual_value: String,
    line_number: u32,
    /// For equality patterns where we need to show the expected value
    expected_value: Option<String>,
    /// The specific pattern node that failed
    error_node: &'static PatternNode,
}

/// Collected assertion errors for reporting.
#[derive(Debug)]
pub struct ErrorReport {
    errors: Vec<ErrorContext>,
    /// Absolute path to the source file, derived at construction time.
    file_path: PathBuf,
}

impl ErrorReport {
    pub fn new(manifest_dir: &str, file_path: &str) -> Self {
        ErrorReport {
            errors: Vec::new(),
            file_path: absolute_source_path(manifest_dir, file_path),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.errors.is_empty()
    }

    pub fn push(
        &mut self,
        error_node: &'static PatternNode,
        line_number: u32,
        actual: String,
        expected: Option<String>,
    ) {
        self.errors.push(ErrorContext {
            actual_value: actual,
            line_number,
            expected_value: expected,
            error_node,
        });
    }
}

/// Build a human-readable annotation label for a failed assertion.
fn error_label(error: &ErrorContext) -> String {
    match &error.error_node.kind {
        NodeKind::Comparison {
            op: ComparisonOp::Equal,
            ..
        } => format!(
            "expected {}, got {}",
            error.expected_value.as_deref().unwrap_or("?"),
            error.actual_value,
        ),
        NodeKind::EnumVariant { .. } => format!(
            "expected variant {}, got {}",
            error.error_node, error.actual_value,
        ),
        NodeKind::Slice { .. } => format!(
            "slice length or structure mismatch, got {}",
            error.actual_value,
        ),
        NodeKind::Closure { .. } => format!(
            "closure condition not satisfied, got {}",
            error.actual_value,
        ),
        _ => format!("got {}", error.actual_value),
    }
}

/// Tree-based pattern representation, generated by the macro at compile time.
pub struct PatternNode {
    pub kind: NodeKind,
    pub parent: Option<&'static PatternNode>,
    pub line: u32,
    pub column: u32,
}

/// The kind of pattern node.
#[derive(Debug)]
pub enum NodeKind {
    // Structural patterns
    Struct {
        name: &'static str,
        fields: &'static [(&'static str, &'static PatternNode)],
    },

    // Collection patterns
    Slice {
        items: &'static [&'static PatternNode],
    },
    Tuple {
        items: &'static [&'static PatternNode],
    },
    Map {
        entries: &'static [(&'static str, &'static PatternNode)],
    },

    // Enum patterns
    EnumVariant {
        path: &'static str,
        args: Option<&'static [&'static PatternNode]>,
    },

    // Leaf patterns
    Simple {
        value: &'static str,
    },
    Comparison {
        op: ComparisonOp,
        value: &'static str,
    },
    Range {
        pattern: &'static str,
    },
    Regex {
        pattern: &'static str,
    },
    Like {
        expr: &'static str,
    },

    // Special
    Rest,
    Wildcard,
    Closure {
        closure: &'static str,
    },
}

/// Comparison operators used in patterns.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ComparisonOp {
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Equal,
    NotEqual,
}

impl ComparisonOp {
    /// Get the string representation of this operator
    pub fn as_str(&self) -> &'static str {
        match self {
            ComparisonOp::Less => "<",
            ComparisonOp::LessEqual => "<=",
            ComparisonOp::Greater => ">",
            ComparisonOp::GreaterEqual => ">=",
            ComparisonOp::Equal => "==",
            ComparisonOp::NotEqual => "!=",
        }
    }
}

impl fmt::Display for ErrorReport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.errors.is_empty() {
            return Ok(());
        }

        let source_content = std::fs::read_to_string(&self.file_path).ok();

        // Pre-compute labels so their lifetimes outlive the report construction.
        let labels: Vec<String> = self.errors.iter().map(error_label).collect();

        let renderer = Renderer::styled();
        let file_path_str = self.file_path.to_string_lossy();

        if let Some(source) = &source_content {
            let annotations: Vec<_> = self
                .errors
                .iter()
                .zip(labels.iter())
                .map(|(error, label)| {
                    let start =
                        byte_offset_of(source, error.line_number, error.error_node.column);
                    // Use the pattern's display text length to size the highlight span.
                    let pattern_len = error.error_node.to_string().len().max(1);
                    let end = (start + pattern_len).min(source.len());
                    AnnotationKind::Primary
                        .span(start..end)
                        .label(label.as_str())
                })
                .collect();

            let snippet = Snippet::source(source.as_str())
                .line_start(1)
                .path(&file_path_str)
                .annotations(annotations);

            let report = Level::ERROR
                .primary_title("assert_struct! failed")
                .element(snippet);

            write!(f, "{}", renderer.render(&[report]))?;
        } else {
            // Fallback when the source file cannot be read.
            write!(f, "assert_struct! failed:")?;
            for label in &labels {
                write!(f, "\n  {label}")?;
            }
        }

        Ok(())
    }
}

impl fmt::Debug for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PatternNode")
            .field("kind", &self.kind)
            .field("parent", &self.parent.map(|_| "<parent>"))
            .field("line", &self.line)
            .field("column", &self.column)
            .finish()
    }
}

impl fmt::Display for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.kind {
            NodeKind::Struct { name, .. } => write!(f, "{} {{ ... }}", name),
            NodeKind::Slice { .. } => write!(f, "[...]"),
            NodeKind::Tuple { items } => write!(f, "({})", ".., ".repeat(items.len())),
            NodeKind::Map { entries } => write!(f, "#{{ {} entries }}", entries.len()),
            NodeKind::EnumVariant { path, args } => {
                if args.is_some() {
                    write!(f, "{}(...)", path)
                } else {
                    write!(f, "{}", path)
                }
            }
            NodeKind::Simple { value } => write!(f, "{}", value),
            NodeKind::Comparison { op, value } => write!(f, "{} {}", op.as_str(), value),
            NodeKind::Range { pattern } => write!(f, "{}", pattern),
            NodeKind::Regex { pattern } => write!(f, "=~ {}", pattern),
            NodeKind::Like { expr } => write!(f, "=~ {}", expr),
            NodeKind::Rest => write!(f, ".."),
            NodeKind::Wildcard => write!(f, "_"),
            NodeKind::Closure { closure } => write!(f, "{}", closure),
        }
    }
}
