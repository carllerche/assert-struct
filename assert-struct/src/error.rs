//! Error types and formatting for assert_struct macro failures.

use std::fmt;
use std::path::PathBuf;

use annotate_snippets::{AnnotationKind, Level, Renderer, Snippet};

/// Find the absolute path for a workspace-relative source file path.
/// `file!()` in a Rust workspace returns a path relative to the workspace root,
/// but the CWD at test runtime is the package root (one level deeper).
/// Walk up from CWD until we find a base directory where the relative path exists.
fn resolve_source_file(relative: &str) -> Option<PathBuf> {
    let rel = std::path::Path::new(relative);
    if rel.is_absolute() {
        return rel.exists().then(|| rel.to_owned());
    }
    let cwd = std::env::current_dir().ok()?;
    let mut dir = cwd.as_path();
    loop {
        let candidate = dir.join(rel);
        if candidate.exists() {
            return Some(candidate);
        }
        dir = dir.parent()?;
    }
}

/// Compute the byte offset of a (line, col) position within a source string.
/// Both `line` and `col` are 1-indexed (as returned by Rust's `line!()` / `column!()`).
fn byte_offset_of(source: &str, line: u32, col: u32) -> usize {
    let line_start: usize = source
        .split('\n')
        .take((line - 1) as usize)
        .map(|l| l.len() + 1) // +1 for the '\n'
        .sum();
    (line_start + col.saturating_sub(1) as usize).min(source.len())
}

/// Context information for a failed assertion.
#[derive(Debug, Clone)]
#[allow(dead_code)]
struct ErrorContext {
    actual_value: String,
    line_number: u32,
    /// For equality patterns where we need to show the expected value
    expected_value: Option<String>,
    /// The specific pattern node that failed
    error_node: &'static PatternNode,
}

/// Collected assertion errors for reporting.
#[derive(Debug)]
pub struct ErrorReport {
    errors: Vec<ErrorContext>,
    file_path: String,
}

impl ErrorReport {
    pub fn new(file_path: &str) -> Self {
        ErrorReport {
            errors: Vec::new(),
            file_path: file_path.to_string(),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.errors.is_empty()
    }

    pub fn push(
        &mut self,
        error_node: &'static PatternNode,
        line_number: u32,
        actual: String,
        expected: Option<String>,
    ) {
        self.errors.push(ErrorContext {
            actual_value: actual,
            line_number,
            expected_value: expected,
            error_node,
        });
    }
}

/// Build a human-readable annotation label for a failed assertion.
fn error_label(error: &ErrorContext) -> String {
    match &error.error_node.kind {
        NodeKind::Comparison {
            op: ComparisonOp::Equal,
            ..
        } => format!(
            "expected {}, got {}",
            error.expected_value.as_deref().unwrap_or("?"),
            error.actual_value,
        ),
        NodeKind::EnumVariant { .. } => format!(
            "expected variant {}, got {}",
            error.error_node, error.actual_value,
        ),
        NodeKind::Slice { .. } => format!(
            "slice length or structure mismatch, got {}",
            error.actual_value,
        ),
        NodeKind::Closure { .. } => format!(
            "closure condition not satisfied, got {}",
            error.actual_value,
        ),
        _ => format!("got {}", error.actual_value),
    }
}

/// Tree-based pattern representation, generated by the macro at compile time.
pub struct PatternNode {
    pub kind: NodeKind,
    pub parent: Option<&'static PatternNode>,
    pub line: u32,
    pub column: u32,
}

/// The kind of pattern node.
#[derive(Debug)]
pub enum NodeKind {
    // Structural patterns
    Struct {
        name: &'static str,
        fields: &'static [(&'static str, &'static PatternNode)],
    },

    // Collection patterns
    Slice {
        items: &'static [&'static PatternNode],
    },
    Tuple {
        items: &'static [&'static PatternNode],
    },
    Map {
        entries: &'static [(&'static str, &'static PatternNode)],
    },

    // Enum patterns
    EnumVariant {
        path: &'static str,
        args: Option<&'static [&'static PatternNode]>,
    },

    // Leaf patterns
    Simple {
        value: &'static str,
    },
    Comparison {
        op: ComparisonOp,
        value: &'static str,
    },
    Range {
        pattern: &'static str,
    },
    Regex {
        pattern: &'static str,
    },
    Like {
        expr: &'static str,
    },

    // Special
    Rest,
    Wildcard,
    Closure {
        closure: &'static str,
    },
}

/// Comparison operators used in patterns.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ComparisonOp {
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Equal,
    NotEqual,
}

impl ComparisonOp {
    /// Get the string representation of this operator
    pub fn as_str(&self) -> &'static str {
        match self {
            ComparisonOp::Less => "<",
            ComparisonOp::LessEqual => "<=",
            ComparisonOp::Greater => ">",
            ComparisonOp::GreaterEqual => ">=",
            ComparisonOp::Equal => "==",
            ComparisonOp::NotEqual => "!=",
        }
    }
}

impl fmt::Display for ErrorReport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.errors.is_empty() {
            return Ok(());
        }

        let source_content = resolve_source_file(&self.file_path)
            .and_then(|p| std::fs::read_to_string(p).ok());

        // Pre-compute labels so their lifetimes outlive the report construction.
        let labels: Vec<String> = self.errors.iter().map(error_label).collect();

        let renderer = Renderer::styled();

        if let Some(source) = &source_content {
            let annotations: Vec<_> = self
                .errors
                .iter()
                .zip(labels.iter())
                .map(|(error, label)| {
                    let start =
                        byte_offset_of(source, error.line_number, error.error_node.column);
                    // Use the pattern's display text length to size the highlight span.
                    let pattern_len = error.error_node.to_string().len().max(1);
                    let end = (start + pattern_len).min(source.len());
                    AnnotationKind::Primary
                        .span(start..end)
                        .label(label.as_str())
                })
                .collect();

            let snippet = Snippet::source(source.as_str())
                .line_start(1)
                .path(&self.file_path)
                .annotations(annotations);

            let report = Level::ERROR
                .primary_title("assert_struct! failed")
                .element(snippet);

            write!(f, "{}", renderer.render(&[report]))?;
        } else {
            // Fallback when the source file cannot be read.
            write!(f, "assert_struct! failed:")?;
            for label in &labels {
                write!(f, "\n  {label}")?;
            }
        }

        Ok(())
    }
}

impl fmt::Debug for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PatternNode")
            .field("kind", &self.kind)
            .field("parent", &self.parent.map(|_| "<parent>"))
            .field("line", &self.line)
            .field("column", &self.column)
            .finish()
    }
}

impl fmt::Display for PatternNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.kind {
            NodeKind::Struct { name, .. } => write!(f, "{} {{ ... }}", name),
            NodeKind::Slice { .. } => write!(f, "[...]"),
            NodeKind::Tuple { items } => write!(f, "({})", ".., ".repeat(items.len())),
            NodeKind::Map { entries } => write!(f, "#{{ {} entries }}", entries.len()),
            NodeKind::EnumVariant { path, args } => {
                if args.is_some() {
                    write!(f, "{}(...)", path)
                } else {
                    write!(f, "{}", path)
                }
            }
            NodeKind::Simple { value } => write!(f, "{}", value),
            NodeKind::Comparison { op, value } => write!(f, "{} {}", op.as_str(), value),
            NodeKind::Range { pattern } => write!(f, "{}", pattern),
            NodeKind::Regex { pattern } => write!(f, "=~ {}", pattern),
            NodeKind::Like { expr } => write!(f, "=~ {}", expr),
            NodeKind::Rest => write!(f, ".."),
            NodeKind::Wildcard => write!(f, "_"),
            NodeKind::Closure { closure } => write!(f, "{}", closure),
        }
    }
}
